// Generated by CoffeeScript 1.3.3
(function() {
  "use strict";

  var rw,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  rw = {};

  rw.funcs = {
    read_write_able: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      return this.write_able.apply(this, args);
    },
    rw_keys: function() {
      var _ref;
      return (_ref = this.__rw_keys) != null ? _ref : this.__rw_keys = [];
    },
    rw_data: function() {
      var args, k, v, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = this.__d) == null) {
        this.__d = {};
      }
      if (args.length === 0) {
        return this.__d;
      } else if (args.length === 2) {
        k = args[0];
        v = args[1];
        if (!(__indexOf.call(this.rw_keys(), k) >= 0)) {
          throw new Error("Unknown key being set: " + k);
        }
        return this.__d[k] = v;
      } else {
        throw new Error("Unknown arguments: " + args);
      }
    },
    read_able: function() {
      var args, prop, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        target.rw_keys().push(prop);
        _results.push(target[prop] = new Function("return this.rw_data()[\"" + prop + "\"];  "));
      }
      return _results;
    },
    write_able: function() {
      var args, prop, target, _i, _len, _ref, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        if ((_ref = target.write_ables) == null) {
          target.write_ables = [];
        }
        _results.push(target.write_ables.push(prop));
      }
      return _results;
    },
    read_able_bool: function() {
      var args, b, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        _results.push(target[b] = new Function("return !!this.rw_data()[\"" + b + "\"];"));
      }
      return _results;
    },
    write_able_bool: function() {
      var args, b, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.write_able.apply(this, args);
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        _results.push(target[b] = new Function('val', "\n  var prop = \"" + b + "\";\n  var data = this.rw_data();\n  var final = null;\n\n  switch( arguments.length ) {\n    case 0:\n      final = !!data[prop];\n      break;\n    case 1:\n      final = ( data[prop] = !!val);\n      break;\n    default:\n      throw new Error(\"Unknown arguments: \" + arguments.join(', '));\n  };\n  return final;"));
      }
      return _results;
    },
    read_write_able_bool: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able_bool.apply(this, args);
      return this.write_able_bool.apply(this, args);
    },
    write: function(prop, val) {
      if (!(__indexOf.call(this['write_ables'], prop) >= 0)) {
        throw new Error("" + prop + " is not write_able.");
      }
      return this.rw_data()[prop] = val;
    }
  };

  rw.on_prototype = ["write", "rw_keys", "rw_data"];

  rw.on_this = ["read_able", "write_able", "read_write_able", "read_able_bool", "write_able_bool", "read_write_able_bool"];

  exports.ize = function(klass) {
    var m, proto, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (klass.read_able) {
      return null;
    }
    proto = klass.prototype || klass;
    _ref = rw.on_prototype;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      proto[m] = rw.funcs[m];
    }
    _ref1 = rw.on_this;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      _results.push(klass[m] = rw.funcs[m]);
    }
    return _results;
  };

}).call(this);
