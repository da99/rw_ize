// Generated by CoffeeScript 1.3.3
(function() {
  var rw,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  rw = {};

  rw.funcs = {
    read_write_able: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      return this.write_able.apply(this, args);
    },
    rw_keys: function() {
      var _ref;
      return (_ref = this.__rw_keys) != null ? _ref : this.__rw_keys = [];
    },
    rw_data: function() {
      var args, k, v, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = this.__d) == null) {
        this.__d = {};
      }
      if (args.length === 0) {
        return this.__d;
      } else if (args.length === 2) {
        k = args[0];
        v = args[1];
        if (!(__indexOf.call(this.rw_keys(), k) >= 0)) {
          throw new Error("Unknown key being set: " + k);
        }
        return this.__d[k] = v;
      } else {
        throw new Error("Unknown arguments: " + args);
      }
    },
    read_able: function() {
      var args, prop, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        target.rw_keys().push(prop);
        target[prop] = function() {
          return this.rw_data()[arguments.callee.rw_name];
        };
        _results.push(target[prop].rw_name = prop);
      }
      return _results;
    },
    write_able: function() {
      var args, prop, target, _i, _len, _ref, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        if ((_ref = target.write_ables) == null) {
          target.write_ables = [];
        }
        _results.push(target.write_ables.push(prop));
      }
      return _results;
    },
    read_able_bool: function() {
      var args, b, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        target[b] = function() {
          return !!this.rw_data()[arguments.callee.rw_name];
        };
        _results.push(target[b].rw_name = b);
      }
      return _results;
    },
    write_able_bool: function() {
      var args, b, target, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.write_able.apply(this, args);
      target = this.prototype || this;
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        target[b] = function(val) {
          var me;
          me = arguments.callee;
          switch (arguments.length) {
            case 0:
              return !!this.rw_data()[me.rw_name];
            case 1:
              return this.rw_data()[me.rw_name] = !!val;
            default:
              throw new Error("Unknown arguments: " + (arguments.join(', ')));
          }
        };
        _results.push(target[b].rw_name = b);
      }
      return _results;
    },
    read_write_able_bool: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able_bool.apply(this, args);
      return this.write_able_bool.apply(this, args);
    },
    write: function(prop, val) {
      if (!(__indexOf.call(this['write_ables'], prop) >= 0)) {
        throw new Error("" + prop + " is not write_able.");
      }
      return this.rw_data()[prop] = val;
    }
  };

  rw.on_prototype = ["write", "rw_keys", "rw_data"];

  rw.on_this = ["read_able", "write_able", "read_write_able", "read_able_bool", "write_able_bool", "read_write_able_bool"];

  exports.ize = function(klass) {
    var m, proto, this_func, _i, _j, _len, _len1, _ref, _ref1, _results;
    this_func = arguments.callee;
    if (this_func.read_able) {
      return null;
    }
    proto = klass.prototype || klass;
    _ref = rw.on_prototype;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      proto[m] = rw.funcs[m];
    }
    _ref1 = rw.on_this;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      m = _ref1[_j];
      _results.push(klass[m] = rw.funcs[m]);
    }
    return _results;
  };

}).call(this);
