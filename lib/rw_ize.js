// Generated by CoffeeScript 1.3.3
(function() {
  "use strict";

  var RW_Key, rw,
    __slice = [].slice;

  RW_Key = (function() {
    var v, _i, _len, _ref;

    RW_Key.reader_code = function(prop) {
      return "if ( arguments.length == 0 )\n  this.throw_unless_rw( '" + prop + "', 'read' );\nelse\n  this.throw_unless_rw( '" + prop + "', 'write' );\nreturn this.read_or_write.apply( this, [\"" + prop + "\"].concat( Array.prototype.slice.call(arguments) ) );";
    };

    function RW_Key(n) {
      this._name_ = n;
      this._is_read_able = false;
      this._is_write_able = false;
      this._is_bool_ = false;
    }

    RW_Key.prototype.name = function() {
      return this._name_;
    };

    _ref = ['read_able', 'write_able', 'bool'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      RW_Key.prototype["is_" + v] = new Function("if (arguments.length === 1 ) {\n  this._is_" + v + "_ = !!(arguments[0]);\n};\nreturn this._is_" + v + "_;");
    }

    RW_Key.prototype.is_read_write_able = function() {
      return this.is_read_able() && this.is_write_able();
    };

    RW_Key.prototype.is_public = function() {
      return this.is_read_write_able();
    };

    RW_Key.prototype.is_private = function() {
      return !this.is_read_write_able();
    };

    return RW_Key;

  })();

  rw = {};

  rw.class_dsl = {
    rw_get_set: function(type, n, val) {
      var k, keys, target;
      target = this.prototype || this;
      switch (type) {
        case 'key':
          keys = target.rw_keys();
          k = keys[n];
          if (!k) {
            k = keys[n] = new RW_Key(n);
          }
          return k;
        case 'func':
          return target[n] = val;
        default:
          throw new Error("Unknown value: " + type);
      }
    },
    private_ize: function() {
      var args, k, prop, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        k = this.rw_get_set('key', prop);
        k.is_read_able(false);
        _results.push(k.is_write_able(false));
      }
      return _results;
    },
    read_write_able: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      return this.write_able.apply(this, args);
    },
    read_able: function() {
      var args, prop, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        this.rw_get_set('key', prop).is_read_able(true);
        _results.push(this.rw_get_set('func', prop, new Function(RW_Key.reader_code(prop))));
      }
      return _results;
    },
    write_able: function() {
      var args, prop, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        prop = args[_i];
        this.rw_get_set('key', prop).is_write_able(true);
        _results.push(this.rw_get_set('func', prop, new Function(RW_Key.reader_code(prop))));
      }
      return _results;
    },
    read_able_bool: function() {
      var args, b, k, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able.apply(this, args);
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        k = this.rw_get_set('key', b);
        _results.push(k.is_bool(true));
      }
      return _results;
    },
    write_able_bool: function() {
      var args, b, k, _i, _len, _results;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.write_able.apply(this, args);
      _results = [];
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        b = args[_i];
        k = this.rw_get_set('key', b);
        _results.push(k.is_bool(true));
      }
      return _results;
    },
    read_write_able_bool: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.read_able_bool.apply(this, args);
      return this.write_able_bool.apply(this, args);
    }
  };

  rw.instance_dsl = {
    rw_key: function(n) {
      return this.rw_keys()[n];
    },
    rw_keys: function(n) {
      var _ref;
      return (_ref = this._rw_keys_) != null ? _ref : this._rw_keys_ = {};
    },
    throw_unless_rw: function(name, action) {
      var key;
      key = this.rw_key(name);
      if (!key["is_" + action + "_able"]()) {
        throw new Error("Key is not " + action + "_able: " + name);
      }
      return true;
    },
    read_or_write: function() {
      var args, d, key, key_name, v, value, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if ((_ref = this._rw_data_) == null) {
        this._rw_data_ = {};
      }
      d = this._rw_data_;
      key_name = args[0];
      value = args[1];
      key = this.rw_key(key_name);
      if (!key) {
        throw new Error("Key not found: " + key_name);
      }
      switch (args.length) {
        case 2:
          if (key.is_bool()) {
            value = !!value;
          }
          return d[key.name()] = value;
        case 1:
          value = d[key.name()];
          if (key.is_bool()) {
            return !!value;
          } else {
            return value;
          }
          break;
        default:
          throw new Error("Unknown arguments: " + ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = args.length; _i < _len; _i++) {
              v = args[_i];
              _results.push(v);
            }
            return _results;
          })()));
      }
    }
  };

  exports.ize = function(obj) {
    var func, name, proto, _ref, _ref1, _results;
    if (obj.read_able) {
      throw new Error("Object has alread been rw_iz'ed.");
    }
    if ((!obj.prototype) && obj.constructor.read_able) {
      throw new Error("Unable to add to an instance with a prototype already rw_iz'ed.");
    }
    proto = obj.prototype || obj;
    _ref = rw.instance_dsl;
    for (name in _ref) {
      func = _ref[name];
      proto[name] = func;
    }
    _ref1 = rw.class_dsl;
    _results = [];
    for (name in _ref1) {
      func = _ref1[name];
      _results.push(obj[name] = func);
    }
    return _results;
  };

  exports.ize.RW_Key = RW_Key;

}).call(this);
